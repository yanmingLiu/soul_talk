import 'dart:async';
import 'dart:math';

import 'package:flutter/widgets.dart';
import 'package:get/get.dart';
import 'package:soul_talk/core/analytics/analytics_service.dart';
import 'package:soul_talk/core/constants/api_values.dart';
import 'package:soul_talk/data/lo_pi.dart';
import 'package:soul_talk/data/ma_pi.dart';
import 'package:soul_talk/data/ms_pi.dart';
import 'package:soul_talk/domain/entities/figure.dart';
import 'package:soul_talk/domain/entities/figure_image.dart';
import 'package:soul_talk/presentation/v000/loading.dart';
import 'package:soul_talk/presentation/v000/toast.dart';
import 'package:soul_talk/presentation/v000/v_dialog.dart';
import 'package:soul_talk/router/app_routers.dart';
import 'package:soul_talk/utils/trans_utils.dart';

import '../../../app/di_depency.dart';
import '../../../core/services/trade_service.dart';
import '../../../domain/entities/a_level.dart';
import '../../../domain/entities/coversation.dart';
import '../../../domain/entities/message.dart';
import '../../../domain/value_objects/enums.dart';
import 'conver_bloc.dart';

class MsgBloc extends GetxController {
  var list = <Message>[].obs;

  RxList inputTags = [].obs;

  late Figure role;
  late Conversation session;
  int? get sessionId => session.id;

  bool isNewChat = false;

  // ç›¸å†Œå˜åŠ¨
  var roleImagesChaned = 0.obs;

  // èŠå¤©ç­‰çº§å˜åŠ¨
  Rx<AnserLevel?> chatLevel = Rx<AnserLevel?>(null);

  List<Map<String, dynamic>> chatLevelConfigs = [];

  List<Map<String, dynamic>> chatLevelList = [
    {'icon': 'ğŸ‘‹', 'text': 'Level 1 Reward', 'level': 1, 'gems': 0},
    {'icon': 'ğŸ¥±', 'text': 'Level 2 Reward', 'level': 2, 'gems': 0},
    {'icon': 'ğŸ˜Š', 'text': 'Level 3 Reward', 'level': 3, 'gems': 0},
    {'icon': 'ğŸ’“', 'text': 'Level 4 Reward', 'level': 4, 'gems': 0},
  ];

  // å‘é€id
  var tmpSendId = '3645411565280';
  Message? tmpSendMsg;

  bool isRecieving = false; // æ­£åœ¨æ¥æ”¶æ¶ˆæ¯

  @override
  void onInit() {
    super.onInit();

    // è·å–ä¼ é€’çš„å‚æ•°
    var arguments = Get.arguments;
    if (arguments != null) {
      role = arguments['role'];
      session = arguments['session'];
    }

    setupTease();

    loadMsg();

    loadChatLevel();

    DI.login.loadPriceConfig();
    DI.login.fetchUserInfo();
  }

  Future loadMsg() async {
    if (sessionId == null) {
      return;
    }
    list.clear();
    _addDefaaultTips();
    final records = await MsgApi.messageList(1, 10000, sessionId!) ?? [];

    // è·å–å·²ç¿»è¯‘æ¶ˆæ¯ id
    final Set<String> ids = DI.storage.translationMsgIds;
    // éå†æ¶ˆæ¯åˆ—è¡¨ï¼Œèµ‹å€¼ showTranslate
    for (var msg in records) {
      if (msg.id != null && ids.contains(msg.id)) {
        msg.showTranslate = true;
      }
      if (DI.login.currentUser?.autoTranslate == true &&
          msg.translateAnswer != null) {
        msg.showTranslate = true;
      }
    }

    list.addAll(records);
  }

  void _addDefaaultTips() {
    final tips = Message();
    tips.source = MsgType.tips;
    tips.answer = 'Replies are generated by Al and fetional';
    list.add(tips);

    var scenario = session.scene ?? role.scenario;

    if (scenario != null && scenario.isNotEmpty) {
      final intro = Message();
      intro.source = MsgType.scenario;
      intro.answer = scenario;
      list.add(intro);
    } else {
      if (role.aboutMe != null && role.aboutMe!.isNotEmpty) {
        final intro = Message();
        intro.source = MsgType.intro;
        intro.answer = role.aboutMe;
        list.add(intro);
      }
    }
    _addRandomGreetings();
  }

  Future<void> _addRandomGreetings() async {
    final greetings = role.greetings;

    if (greetings == null || greetings.isEmpty) {
      return;
    }
    int randomIndex = Random().nextInt(greetings.length);
    var str = greetings[randomIndex];

    final msg = Message();
    msg.id = '${DateTime.now().millisecondsSinceEpoch}';
    msg.answer = str;
    // msg.voiceUrl = voiceUrl;
    // msg.voiceDur = voiceDur;
    msg.source = MsgType.welcome;
    list.add(msg);
  }

  void setupTease() {
    inputTags.clear();

    if (DI.storage.isBest) {
      inputTags.add({
        'id': 0,
        'name': 'Tease',
        'icon': 'assets/images/msghoticon.png',
        'color': 0xFF85FFCD,
        "list": [
          "What's the most unforgettable intimate moment you've ever shared with someone?",
          "How much experience do you have with romantic and physical relationships?",
          "Have you ever dated someone who was previously with your friend?",
          "What setting did your first romantic intimate experience happen in?",
          "If you could choose any spot for a deeply romantic moment, where would it be?",
          "Is there a specific style or approach you prefer for physical intimacy?",
          "Would you be open to trying new experiences when it comes to intimacy?",
          "Do you find a curvy figure or a toned body more attractive?",
          "What's the most heartfelt romantic line someone has whispered to you during an intimate moment?",
          "Can you craft a romantic moment that someone will remember for a lifetime?",
          "What time or situation makes you crave a romantic connection the most?",
          "Would you share something personal or private about yourself with me?",
          "Would you be up for exchanging romantic or intimate photos?",
          "Could you show me a picture of yourself?",
          "What's the deepest romantic connection you've ever had?",
          "Have you ever had a romantic experience that felt truly magical?",
          "Do you prefer slow, tender intimacy or more passionate moments?",
          "Have you ever liked someone who was dating your friend at the time?",
          "Where's the most unexpected place you've had a romantic encounter?",
          "If you could reenact a romantic moment, what would it be and where?",
          "Are there any boundaries you have when it comes to physical intimacy?",
          "What physical trait do you find most alluring in a romantic partner?",
          "What's the most touching thing someone has done for you during an intimate moment?",
          "Do you think you can make a romantic moment feel unique and unforgettable?",
          "What triggers your strongest desire for a deep romantic bond?",
          "Is there a private detail about your romantic life you're willing to share?",
          "Would you consider swapping personal romantic snapshots with me?",
          "Would it be okay if I asked to see a photo of you?",
          "Have you ever had an intimate moment that changed how you view romance?",
          "How do you usually express intimacy in a romantic relationship?",
        ],
      });
    }

    inputTags.add({
      'id': 3,
      'name': 'Mask',
      'icon': 'assets/images/msgbtnmask.png',
      'color': 0xFFFEB6EA,
      'list': [],
    });

    if (DI.storage.isBest) {
      final count = DI.storage.sendMsgCount;
      final showClothingCount = TradeService.showClothingCount;
      if (count >= showClothingCount) {
        inputTags.add({
          'id': 1,
          'name': 'Undress',
          'icon': 'assets/images/msgbtnundre.png',
          'color': 0xFFFEB6EA,
          'list': [],
        });
      }
    }
  }

  Future<void> rechage() async {
    await Toast.toast("Not enough Coins, call ended.");
    // v1.3.0 - è°ƒæ•´ä¸ºè·³è®¢é˜…é¡µ
    AppRoutes.pushVip(VipSF.send);
  }

  Future<bool> canSendMsg(String text) async {
    if (isRecieving) {
      await Toast.toast("Please wait for the response");
      return false;
    }

    Message lastMsg = list.last;
    if (lastMsg.typewriterAnimated) {
      await Toast.toast("Please wait for the response");
      return false;
    }

    if (text.isEmpty) {
      await Toast.toast("Please input something");
      return false;
    }
    final roleId = role.id;
    if (roleId == null) {
      return false;
    }
    if (!DI.login.vipStatus.value) {
      if (role.gems == true) {
        final flag = DI.login.checkBalance(ConsSF.text);
        if (!flag) {
          rechage();
          return false;
        }
      } else {
        /// å…è´¹è§’è‰² - æœ€å¤§å…è´¹æ¡æ•°
        int maxCount = TradeService.maxFreeChatCount;

        final sencCount = DI.storage.sendMsgCount;

        if (sencCount > maxCount) {
          VDialog.alert(
            message:
                "You've used up your free chat credits. To continue enjoying our service, please consider upgrading to our premium plan.",
            confirmText: "Upgrade to chat",
            onConfirm: () {
              logEvent('t_chat_send');
              AppRoutes.pushVip(VipSF.send);
            },
          );
          return false;
        }
      }
    }
    return true;
  }

  void checkSendCount() async {
    // å‘é€æˆåŠŸåï¼Œæ›´æ–°å‘é€æ¬¡æ•°

    await DI.storage.setSendMsgCount(DI.storage.sendMsgCount + 1);
    setupTease();

    if (DI.storage.isBest) {
      var count = DI.storage.sendMsgCount;
      if (count == TradeService.showClothingCount) {
        VDialog.alert(
          message:
              "Congrats on unlocking the Easter egg feature! You can now upload images to explore the undress function. Give it a shot!",
          confirmText: "Yes",
          clickMaskDismiss: false,
          onConfirm: () {
            VDialog.dismiss();
            AppRoutes.pushMakeRole(role);
          },
        );
      } else {
        checkRateMsgCount();
      }
    } else {
      checkRateMsgCount();
    }
  }

  void checkRateMsgCount() async {
    DI.storage.setRateCount(DI.storage.rateCount + 1);

    if (DI.storage.rateCount == 8) {
      VDialog.showRateUs(
        "Thank you for chatting with me for so long! If you think we had a good chat, please give me a five-star rating? (>Ï‰<)",
      );
    }
  }

  Future<bool> resetConv() async {
    Loading.show();
    var result = await MsgApi.resetSession(sessionId ?? 0);
    Loading.dismiss();
    if (result != null) {
      session = result;
      list.clear();
      _addDefaaultTips();
      return true;
    }
    return false;
  }

  Future<bool> deleteConv() async {
    Loading.show();
    var result = await MsgApi.deleteSession(sessionId ?? 0);

    if (result && Get.isRegistered<ConverBloc>()) {
      Get.find<ConverBloc>().dataList.removeWhere((r) => r.id == sessionId);
      Get.find<ConverBloc>().dataList.refresh();
    }

    Loading.dismiss();
    return result;
  }

  Future<void> sendMsg(String text) async {
    bool canSend = await canSendMsg(text);
    if (!canSend) {
      return;
    }

    addTemSendMsg(text);

    await sendMsgRequest(path: ApiConstants.sendMsg, text: text);
  }

  void addTemSendMsg(String text) {
    final charId = role.id;
    final conversationId = sessionId ?? 0;
    final uid = DI.login.currentUser?.id;
    if (charId == null || uid == null) {
      Toast.toast('role or sessionId is null');
      return;
    }

    // ä¸´æ—¶å‘é€æ˜¾ç¤ºçš„æ¶ˆæ¯
    final msg = Message(
      id: tmpSendId,
      question: text,
      userId: DI.login.currentUser?.id,
      conversationId: conversationId,
      characterId: charId,
      onAnswer: true,
    );
    msg.source = MsgType.sendText;
    list.add(msg);
    tmpSendMsg = msg;
  }

  Future<void> sendMsgRequest({
    required String path,
    String? text,
    bool? isLoading,
    String? msgId,
  }) async {
    try {
      final charId = role.id;
      final conversationId = sessionId ?? 0;
      final uid = DI.login.currentUser?.id;
      if (charId == null || uid == null || conversationId == 0) {
        Toast.toast('role or sessionId is null');
        return;
      }

      var body = {
        'character_id': charId,
        'conversation_id': conversationId,
        'user_id': uid,
      };
      if (text != null) {
        body['message'] = text;
      }
      if (msgId != null) {
        body['msg_id'] = msgId;
      }

      isRecieving = true;
      if (isLoading == true) {
        Loading.show();
      }
      final res = await MsgApi.sendMsg(path: path, body: body);
      Loading.dismiss();

      final msg = res?.data;
      if (res?.code == 20003) {
        rechage();
        return;
      }
      if (msg != null) {
        await progressReceived(msg);
      } else {
        progressSSEError();
      }
    } catch (e) {
      progressSSEError();
    } finally {
      Loading.dismiss();
      isRecieving = false;
    }
  }

  void progressSSEError() {
    tmpSendMsg?.onAnswer = false;

    Message msg = Message(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      answer: "Hmmâ€¦ we lost connection for a bit. Please try again!",
    );
    msg.source = MsgType.error;
    msg.answer = "Hmmâ€¦ we lost connection for a bit. Please try again!";
    list.add(msg);
  }

  Future<void> progressReceived(Message msg) async {
    if (msg.conversationId != sessionId) {
      return;
    }
    if (msg.textLock == MsgLock.private.value) {
      msg.typewriterAnimated = DI.login.vipStatus.value;
    } else {
      msg.typewriterAnimated = true;
    }

    // åˆ é™¤æœ€åä¸€æ¡tmpSendMsg
    if (list.isNotEmpty &&
        list.last.id == tmpSendId &&
        msg.question == list.last.question) {
      list.removeLast();
    }

    final index = list.indexOf(msg);
    if (index != -1) {
      list[index] = msg;
    } else {
      list.add(msg);
    }
    _checkChatLevel(msg);

    await DI.login.fetchUserInfo();

    tmpSendMsg = null;
  }

  void _checkChatLevel(Message msg) async {
    bool upgrade = msg.upgrade ?? false;
    int rewards = msg.rewards ?? 0;
    var level = msg.appUserChatLevel;
    chatLevel.value = level;
    if (upgrade) {
      // å‡çº§äº†
      await _showChatLevelUp(rewards);

      if ((level?.level ?? 0) == 3) {
        if (VDialog.rateLevel3Shoed == false) {
          VDialog.showRateUs(
            "Thank you for chatting with me for so long! If you think we had a good chat, please give me a five-star rating? (>Ï‰<)",
          );
          VDialog.rateLevel3Shoed = true;
        }
      }
    } else {
      checkSendCount();
    }
  }

  Future _showChatLevelUp(int rewards) async {
    await VDialog.showChatLevelUp(rewards);

    checkSendCount();
  }

  Future<void> loadChatLevel() async {
    if (chatLevelConfigs.isNotEmpty) {
      return;
    }
    try {
      final configs = await MsgApi.getChatLevelConfig() ?? [];
      chatLevelConfigs = configs.isEmpty
          ? chatLevelList
          : configs.map((c) {
              return {
                'icon': c.title ?? 'ğŸ‘‹',
                'level': c.level ?? 1,
                'text': "Level ${c.level} Reward",
                'gems': c.reward ?? 0,
              };
            }).toList();

      final roleId = role.id;
      final userId = DI.login.currentUser?.id;
      if (roleId == null || userId == null) {
        return;
      }
      var res = await MsgApi.fetchChatLevel(charId: roleId, userId: userId);
      chatLevel.value = res;
    } catch (e) {
      debugPrint('[MessageController] : $e');
    }
  }

  Future<void> onTapUnlockImage(FigureImage image) async {
    final gems = image.gems ?? 0;
    if (DI.login.gemBalance.value < gems) {
      AppRoutes.pushGem(ConsSF.album);
      return;
    }

    final imageId = image.id;
    final modelId = image.modelId;
    if (imageId == null || modelId == null) {
      return;
    }

    Loading.show();
    final res = await MsgApi.unlockImageReq(imageId, modelId);
    Loading.dismiss();
    if (res) {
      // åˆ›å»ºä¸€ä¸ªæ–°çš„ images åˆ—è¡¨
      final updatedImages = role.images?.map((i) {
        if (i.id == imageId) {
          return i.copyWith(unlocked: true);
        }
        return i;
      }).toList();

      // æ›´æ–° Role å¯¹è±¡
      role = role.copyWith(images: updatedImages);
      roleImagesChaned.value++;
      DI.login.fetchUserInfo();

      onTapImage(image);
    } else {
      Toast.toast("Hmmâ€¦ we lost connection for a bit. Please try again!");
    }
  }

  void onTapImage(FigureImage image) {
    final imageUrl = image.imageUrl;
    if (imageUrl == null) {
      return;
    }
    AppRoutes.pushImagePreview(imageUrl);
  }

  void translateMsg(Message msg) async {
    Message lastMsg = list.last;
    if (lastMsg.typewriterAnimated) {
      Toast.toast("Wait for response");
      return;
    }

    final content = msg.answer;
    final id = msg.id;

    // å†…å®¹ä¸ºç©ºç›´æ¥è¿”å›
    if (content == null || content.isEmpty) return;

    // å®šä¹‰æ›´æ–°æ¶ˆæ¯çš„æ–¹æ³•
    Future<void> updateMessage({
      required bool showTranslate,
      String? translate,
    }) async {
      msg.showTranslate = showTranslate;

      if (id != null) {
        _transCache(isAdd: showTranslate, id: id);
      }

      if (translate != null) {
        msg.translateAnswer = translate;

        if (id != null) {
          MsgApi.saveMsgTrans(id: id, text: translate);
        }
      }
      list.refresh();
    }

    // æ ¹æ®çŠ¶æ€å¤„ç†é€»è¾‘
    if (msg.showTranslate == true) {
      await updateMessage(showTranslate: false);
    } else if (msg.translateAnswer != null) {
      await updateMessage(showTranslate: true);
      MsgTransUtils.instance.handleTranslationClick();
    } else {
      logEvent('c_trans');
      if (msg.translateAnswer == null) {
        // è·å–ç¿»è¯‘å†…å®¹
        Loading.show();
        String? result = await LoginApi.translateText(content);
        Loading.dismiss();
        // æ›´æ–°æ¶ˆæ¯å¹¶æ˜¾ç¤ºç¿»è¯‘
        await updateMessage(showTranslate: true, translate: result);
      } else {
        await updateMessage(showTranslate: true);
      }

      MsgTransUtils.instance.handleTranslationClick();
    }
  }

  void _transCache({required bool isAdd, required String id}) {
    final Set<String> ids = DI.storage.translationMsgIds;
    if (isAdd) {
      ids.add(id); // é‡å¤æ·»åŠ ä¼šè‡ªåŠ¨å¿½ç•¥
    } else {
      ids.remove(id);
    }
    DI.storage.setTranslationMsgIds(ids);
  }

  Message? findLastServerMsg() {
    // ä»åå‘å‰éå†æ¶ˆæ¯åˆ—è¡¨
    for (int i = list.length - 1; i >= 0; i--) {
      final msg = list[i];

      // å¦‚æœæ˜¯é”™è¯¯æ¶ˆæ¯ï¼Œåˆ é™¤å®ƒ
      if (msg.source == MsgType.error) {
        list.removeAt(i);
        continue;
      }

      // æ£€æŸ¥æ˜¯å¦ä¸ºæœåŠ¡å™¨æ¶ˆæ¯ç±»å‹
      final source = msg.source;
      if (source == MsgType.text ||
          source == MsgType.video ||
          source == MsgType.audio ||
          source == MsgType.photo ||
          source == MsgType.gift ||
          source == MsgType.clothe) {
        return msg; // æ‰¾åˆ°æœåŠ¡å™¨æ¶ˆæ¯ï¼Œè¿”å›å¹¶åœæ­¢éå†
      }
    }
    return null;
  }

  /// ç»­å†™
  Future<void> continueWriting() async {
    final msg = list.last;
    bool canSend = await canSendMsg(msg.answer ?? '');
    if (!canSend) {
      return;
    }
    await sendMsgRequest(path: ApiConstants.continueWrite, isLoading: true);
  }

  /// é‡æ–°å‘é€æ¶ˆæ¯
  Future<void> resendMsg(Message msg) async {
    Message? last = msg;
    if (msg.source == MsgType.error) {
      last = findLastServerMsg();
    }
    if (last == null) {
      continueWriting();
      return;
    }

    bool canSend = await canSendMsg(last.answer ?? '');
    if (!canSend) {
      return;
    }

    final id = msg.id;
    if (id == null) {
      Toast.toast("Hmmâ€¦ we lost connection for a bit. Please try again!");
      return;
    }

    await sendMsgRequest(
      path: ApiConstants.resendMsg,
      isLoading: true,
      msgId: id,
    );
  }

  /// ç¼–è¾‘æ¶ˆæ¯
  Future<void> editMsg(String content, Message msg) async {
    bool canSend = await canSendMsg(msg.answer ?? '');
    if (!canSend) {
      return;
    }
    Loading.show();
    isRecieving = true;
    final id = msg.id;
    if (id == null) {
      Toast.toast("Hmmâ€¦ we lost connection for a bit. Please try again!");
      return;
    }
    var data = await MsgApi.editMsg(id: id, text: content);
    if (data != null) {
      // æŸ¥æ‰¾ä¸Šä¸€ä¸ª sendtext æ¶ˆæ¯  å¦‚æœå­˜åœ¨questionä¸€æ ·çš„ï¼Œå°†å®ƒåˆ é™¤
      Message? pre = list.firstWhereOrNull(
        (element) => element.question == data.question,
      );
      list.remove(pre);
      // æ›¿æ¢å°±æ¶ˆæ¯
      list.removeWhere((element) => element.id == id);
      list.add(data);
      DI.login.fetchUserInfo();
    }
    isRecieving = false;
    Loading.dismiss();
  }

  /// ä¿®æ”¹èŠå¤©åœºæ™¯
  Future<void> editScene(String scene) async {
    void request() async {
      final charId = role.id;
      final conversationId = sessionId ?? 0;
      if (charId == null || conversationId == 0) {
        Toast.toast("Hmmâ€¦ we lost connection for a bit. Please try again!");
        return;
      }

      bool res = await MsgApi.editScene(
        convId: conversationId,
        scene: scene,
        roleId: charId,
      );
      if (res) {
        session.scene = scene;
        list.clear();
        _addDefaaultTips();
      }
      Loading.dismiss();
    }

    VDialog.alert(
      message:
          "To active the new scenario,the chat wil be restart and the history will lose.",
      cancelText: "Cancel",
      confirmText: "Confirm",
      onConfirm: () {
        VDialog.dismiss();
        request();
      },
    );
  }

  /// ä¿®æ”¹ä¼šè¯æ¨¡å¼ èŠå¤©æ¨¡å‹ short / long
  Future<void> editChatMode(bool isLong) async {
    final conversationId = sessionId ?? 0;
    if (conversationId == 0) {
      Toast.toast("Hmmâ€¦ we lost connection for a bit. Please try again!");
      return;
    }

    var mode = isLong ? 'long' : 'short';
    if (session.chatModel == mode) {
      if (Get.isBottomSheetOpen == true) Get.back();
      return;
    }
    Loading.show();
    bool res = await MsgApi.editChatMode(convId: conversationId, mode: mode);
    if (res) {
      session.chatModel = mode;
      if (Get.isBottomSheetOpen == true) Get.back();
    }
    Loading.dismiss();
  }

  /// åˆ‡æ¢ mask
  Future<bool> changeMask(int maskId) async {
    Loading.show();
    final conversationId = session.id;
    final res = await MaskApi.changeMask(
      conversationId: conversationId,
      maskId: maskId,
    );
    Loading.dismiss();
    if (res) {
      session.profileId = maskId;
      list.clear();
      _addDefaaultTips();
      _addMaskTips();
    }
    return res;
  }

  void _addMaskTips() {
    final msg = Message();
    msg.source = MsgType.maskTips;
    msg.answer =
        "The mask has been put on for you! Modifying the mask doesn't affect the loaded mask's effect.";
    list.add(msg);
  }

  void cleanFormMask() {
    list.clear();
    _addDefaaultTips();
    _addMaskTips();
  }
}
